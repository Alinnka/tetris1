import pygame as pg #pygame - библиотека для создания игр
import random, time, sys  #sys - модуль с функциями, которые позволяют взаимодействовать с интерпретатором, time - модуль для контроля времени
from pygame.locals import *  #locals - содержит константы, которые используются в пайгейм

fps = 30 #кадровая частота
app_width, app_height = 600, 500 # размеры окна
cube, rect_height, rect_width = 20, 20, 15  #размер одной любой фигуры(20х20 пикселей), ширина и высота игрового поля(прибл. одинаковые чтобы можно было привязать к фигуре по размерам)
#для размещения игрового поля, надписей и конвертации координат:
side_distance = int((app_width - rect_width * cube) / 2)  #расстояние между правой и левой границей окна программы и левой и правой стороной игрового поля
top_distance = app_height - (rect_height * cube) - 5  #расстояние между верхней границей окна программы и верхней границей игрового поля;
 #6 ярких цветов(вид самих фигур) - желтый, оранжевый, зеленый, голубой, фиолетовый, красный
brightcolors = ((247, 255, 0), (255, 145, 0), (0, 255, 51), (75, 226, 255), (208, 14, 255), (255, 0, 0))
 #6 темных цветов("блики\тени" для фигур - желтый = какой-то болотный, оранжевый = коричневый, зеленый = темно-зеленый, голубой = темно-голубой, фиолетовый = темно-фиолетовый, красный = темно-красный.
darkcolors = ((168, 174, 20), (164, 101, 20), (24, 166, 43), (24, 138, 166), (141, 15, 161), (206, 36, 36))
#время которое потребуется на перемещение фигуры в сторону или вниз если клавиша удерживается нажатой
side_time = 0.15
down_time = 0.1  #если клавиша будет нажиматься более чем это-кол во времени, фигура продолжит движение далее, чтобы не нажимать клавишу много раз
not_filled = "=" #обозначение для матрицы(игрового поля) что эти свободные ячейки не заполнены блоком из какой-либо фигуры
figure_width, figure_height = 6, 6  #так как каждая фигура состоит из 5 блоков нам нужна матрица 6х6
color_rectangle, color_bg, color_labels, main_label = (0, 0, 0), (221, 221, 221), (139, 36, 139), (10, 125, 91) #цвет границ игрового поля(черный), задний фон(светло-серый), цвет для надписей(сиреневый), цвет для названия игры (изумрудный)
figures = { "C": [["======",  #вид фигур(фигуры - *), каждая фигура имеет свою букву + 4 поворота(исключение - линия(1), зет(2)(зет разбита на две отдельные буквы), x(1), с(3), м(3); всего фигур 12; итого - 38 различных возможных поворотов включая ориг. фигуры
                   "======",  #повороты фигур для исключительных фигур были убраны в следствии удобства игры тк не все повороты appropriate для играбельности
                   "=*=*==",  #словарь с вложенными списками, элементы списка - строки
                   "=***==",  # * - занятые ячейки в матрице(сама фигура); = - незанятые ячейки в матрице (пустые);
                   "======",
                   "======"],
                  ["======",
                   "======",
                   "==**==",
                   "===*==",
                   "==**==",
                   "======"],
                  ["======",
                   "======",
                   "==**==",
                   "==*===",
                   "==**==",
                   "======"]],
            "L": [["======",
                   "======",
                   "=****=",
                   "=*====",
                   "======",
                   "======"],
                  ["======",
                   "==*===",
                   "==*===",
                   "==*===",
                   "==**==",
                   "======"],
                  ["======",
                   "======",
                   "====*=",
                   "=****=",
                   "======",
                   "======"],
                  ["======",
                   "==**==",
                   "===*==",
                   "===*==",
                   "===*==",
                   "======"]],
            "Y": [["======",
                   "======",
                   "==*===",
                   "=****=",
                   "======",
                   "======"],
                  ["======",
                   "===*==",
                   "===*==",
                   "==**==",
                   "===*==",
                   "======"],
                  ["======",
                   "======",
                   "=****=",
                   "===*==",
                   "======",
                   "======"],
                  ["======",
                   "==*===",
                   "==**==",
                   "==*===",
                   "==*===",
                   "======"]],
            "M": [["======",
                   "======",
                   "==**==",
                   "=**===",
                   "=*====",
                   "======"],
                  ["======",
                   "======",
                   "===*==",
                   "==**==",
                   "=**===",
                   "======"],
                  ["======",
                   "======",
                   "=**===",
                   "==**==",
                   "===*==",
                   "======"]],
            "B": [["======",
                   "======",
                   "=***==",
                   "=**===",
                   "======",
                   "======"],
                  ["======",
                   "=*====",
                   "=**===",
                   "=**===",
                   "======",
                   "======"],
                  ["======",
                   "======",
                   "==**==",
                   "=***==",
                   "======",
                   "======"],
                  ["======",
                   "=**===",
                   "=**===",
                   "==*===",
                   "======",
                   "======"]],
            "G": [["======",
                   "======",
                   "==***=",
                   "==*===",
                   "==*===",
                   "======"],
                  ["======",
                   "======",
                   "==*===",
                   "==*===",
                   "==***=",
                   "======"],
                  ["======",
                   "======",
                   "====*=",
                   "====*=",
                   "==***=",
                   "======"],
                  ["======",
                   "======",
                   "==***=",
                   "====*=",
                   "====*=",
                   "======"]],
            "Z": [["======",
                   "======",
                   "==**==",
                   "==*===",
                   "=**===",
                   "======"]],
            "Z2":[["======",
                   "======",
                   "=*====",
                   "=***==",
                   "===*==",
                   "======"]],
            "I": [["======",
                   "==*===",
                   "==*===",
                   "==*===",
                   "==*===",
                   "==*==="]],
            "E": [["======",
                   "======",
                   "===*==",
                   "=***==",
                   "===*==",
                   "======"],
                  ["======",
                   "======",
                   "=***==",
                   "==*===",
                   "==*===",
                   "======"],
                  ["======",
                   "======",
                   "=*====",
                   "=***==",
                   "=*====",
                   "======"],
                  ["======",
                   "======",
                   "==*===",
                   "==*===",
                   "=***==",
                   "======"]],
            "K": [["======",
                   "======",
                   "===*==",
                   "=***==",
                   "==*===",
                   "======"],
                  ["======",
                   "======",
                   "=**===",
                   "==**==",
                   "==*===",
                   "======"],
                  ["======",
                   "======",
                   "==*===",
                   "=***==",
                   "=*====",
                   "======"],
                  ["======",
                   "======",
                   "==*===",
                   "=**===",
                   "==**==",
                   "======"]],
            "X": [["======",
                   "======",
                   "==*===",
                   "=***==",
                   "==*===",
                   "======"]],
            "J": [["======",
                   "===*==",
                   "===*==",
                   "==**==",
                   "==*===",
                   "======"],
                  ["======",
                   "======",
                   "=***==",
                   "===**=",
                   "======",
                   "======"],
                  ["======",
                   "===*==",
                   "==**==",
                   "==*===",
                   "==*===",
                   "======"],
                  ["======",
                   "======",
                   "=**===",
                   "==***=",
                   "======",
                   "======"]]}

def osnova(): #функция в которой задаем основные параметры которые будем далее использовать
    global clock, main_font, other_fonts, app  #дополнительные глобальные константы
    pg.init()  #инициализация pygame-a
    clock = pg.time.Clock()  #чтобы отслеживать время; позже в каждом кадре секунда будет делиться на кол-во фпс и на полученный результат будет выполнена задержка в секундах
    app = pg.display.set_mode((app_width, app_height))  #создать окно с нужными размерами
    main_font = pg.font.SysFont("System полужирный", 60)  #основной и побочные шрифты(название и размер)
    other_fonts = pg.font.SysFont("Courier обычный", 30)  #SysFont - достать стандартный шрифт по его названию из Windows\Fonts(прописываем сами нужный шрифт посмотрев в этой папке его название)
    pg.display.set_caption("TETRIS")  #установить название окна

    while True:  #когда игру хотим начать
        run()  #вызываем функцию запуска игры

        show_text("GAME OVER")  #вызываем сообщение о проигрыше когда на нашем поле не останется свободного места


def run():  #сам тетрис(функция) где совмещаются все остальные функции чтобы собрать игру в кучу + создание других нужных переменных которые пригодятся по ходу игры
    rectangle = empty_game_field()  #вызывать функцию с рисованием(созданием) пустого игрового поля
    last_down_move = time.time()   #следим за последним движением фигуры; time - возвращает время как число с плавающей запятой, выраженное в секундах с момента эпохи, в UTC.
    last_side_move = time.time()   #epoch - дата и время, относительно которых определяются часы компьютера и значения временных меток.
    last_fall = time.time()  #следим за фигурой, которая упала последней
    go_down = False  #движение фигуры на фолс, не может начать двигаться
    go_left = False  #если определенная клавиша будет нажата при проверке ивентов, значение поменяется на ему противоположное - на тру
    go_right = False
    points = 0  #очки набранные
    level, fall_figure_speed = figure_speed(points) #переменные используются в функции которая вычисляет уровень по кол-ву очков и от этого зависит скорость падения фигуры
    falling_fig = get_figure() #переменная, которая отвечает за падающую фигуру, все описано в функции get_figure()
    next_fig = get_figure()   #переменная, которая отвечает за следующую фигуру, все описано в функции get_figure()

    while True:  #бесконечный игровой цикл
        if falling_fig == None:  #если фигура приземлилась то присваиваем этой переменной нан тк уже ничего не приземляется
            falling_fig = next_fig  #следующая фигура которая появится сразу на игровом поле станет падающей
            next_fig = get_figure() #эта следующая фигура которая должна появиться генерируется функцией get_gifure()
            last_fall = time.time() #следим за тем, какая фигура упала последней

            if not check_position(rectangle, falling_fig):  #если мы проверяем позицию фигуры и границы поля и на нем закончилось свободное место(а значит фигуре некуда упасть)- игра заканчивается
                return  #передаем это значение из функции в программу

        Quit()  #если свободное место в поле закончилось и фигуры не падают то игра заканчивается, можем закрыть её с помощью кнопок

        for event in pg.event.get():  #перебираем все ивенты
            #определяет момент когда нажимаем и отпускаем клавиши со стрелками
            if event.type == KEYUP:
                if event.key == K_LEFT:  #стрелка влево
                    go_left = False  #если клавиша влево не нажата, ставим значение на фолс - значит мы не двигаемся налево
                elif event.key == K_RIGHT:  #стрелка направо
                    go_right = False  #если клавиша вправо не нажата, ставим значение на фолс - значит мы не двигаемся направо
                elif event.key == K_DOWN:  #стрелка вниз
                    go_down = False  #если клавиша вниз не нажата, ставим значение на фолс - значит мы не двигаемся вниз
                #далее эти значения будут изменяться на True во время обработки событий клавиатуры, если движение в нужном направлении возможно и мы нажали нужную клавишу
            elif event.type == KEYDOWN:  #управление движением фигур(если нажата клавиша со стрелкой + функция (check_position) вернула тру) то двигаемся
                #фигура будут двигаться на один блок далее со скоростью, которую мы задали в начале + в соответсвующем направлении
                if event.key == K_LEFT and check_position(rectangle, falling_fig, adjX=-1): #если жмём клавишу влево, проверяем есть ли место чтобы падающая текущая фигура двигалась именно туда; -1 тк двигаемся налево(сетка координат)
                    falling_fig["x"]  -= 1 #сдвигаем координаты по х далее на 1 потому что они будут заняты падающей фигурой и мы двигаемся по одному блоку
                    go_left = True  #будем двигаться влево
                    go_right = False  #а направо не будем
                    last_side_move = time.time()  #следим в какую сторону мы последний раз пошли по времени
                elif event.key == K_RIGHT and check_position(rectangle, falling_fig, adjX=1):  #если жмём клавишу вправо, проверяем есть ли место чтобы падающая текущая фигура двигалась именно туда; +1 тк двигаемся направо(сетка координат)
                    falling_fig["x"] += 1  #сдвигаем координату по х далее на 1 потому что они будут заняты падающей фигурой и мы двигаемся по одному блоку
                    go_left = False  #налево не идем
                    go_right = True  #а направо как раз идем
                    last_side_move = time.time()  #следим в какую сторону мы последний раз пошли по времени
                elif event.key == K_UP: #если жмём клавишу вверх то происходит вращение фигуры(возможные ее повороты)
                    #чтобы убедиться что все элементы к которым обращаемся в словаре находятся в диапазоне индексов словаря; можно сделать с помощью функции range() вместе с функцией len() или просто лен
                    #конструкция ниже после равно обнуляет индекс элемента, если инкремент(операция, увеличивающая значение переменной) достиг максимального значения
                    falling_fig['rotation'] = (falling_fig['rotation'] + 1) % len(figures[falling_fig['shape']]) #берем любой поворот фигуры и используем эту конструкцию (если check_position вернуло True)
                    if not check_position(rectangle, falling_fig):  #если повернуть фигуру не получится по причине нехватки места или натыкания на другие фигуры то
                        falling_fig['rotation'] = (falling_fig['rotation'] - 1) % len(figures[falling_fig['shape']])  #возвращаемся к предыдущему варианту из списка, те на предыдущий поворот(вариант) (-1)
                elif event.key == K_DOWN:  #если удерживаем клавишу вниз
                    go_down = True  #сообственно фигура двигается вниз но быстрее чем обычно(ускорение падения)
                    if check_position(rectangle, falling_fig, adjY=1):  #если место есть куда двигаться
                        falling_fig["y"] += 1  #тогда по координате у увеличиваем на один продвигающийся вниз блок\ячейку(двигаем блоки фигуры по у)
                    last_down_move = time.time()  #следим когда по времени последний раз опустили фигуру вниз
                elif event.key == K_RETURN:  #если нажимаем энтер
                    go_down = False  #вниз по обычному не двигаемся потому что просто фигура скинется в буквальном смысле
                    go_left = False  #налево тоже не идем
                    go_right = False  #направо тоже не идем
                    for i in range(1, rect_height):  #определяем по высоте поля самую низкую допустимую свободную позицию на поле куда можем скинуть фигуру
                        if not check_position(rectangle, falling_fig, adjY=i):  #если такой позиции нет то все финита
                            break
                    falling_fig["y"] += i - 1  #если есть - по координате у увеличиваем на столько сколько можем себе позволить
        #тут мы будем проверять сколько мы удерживаем клавишу по времени чтобы управлять падением фигуры и чтобы клавишу удерживать, а не нажимать каждый раз для передвижения
        if (go_left or go_right) and time.time() - last_side_move > side_time: #если жмем клавишу дольше, чем 0.15 или 0.1 секунды – True - фигура продолжит движение в заданном направлении.
            if go_left and check_position(rectangle, falling_fig, adjX=-1): #если идем на лево и проверили позиции то двигаемся далее налево занимая ячейки по х по 1
                falling_fig["x"] -= 1
            elif go_right and check_position(rectangle, falling_fig, adjX=1):  #если идем на право и проверили позиции то двигаемся вправо занимая ячейку по х по 1
                falling_fig["x"] += 1
            last_side_move = time.time()  #продолжаем считать
        if go_down and time.time() - last_down_move > down_time and check_position(rectangle, falling_fig, adjY=1): #движение вниз тоже самое просто идем по координате у а не х
            falling_fig["y"] += 1
            last_down_move = time.time()
        if time.time() - last_fall > fall_figure_speed:  #если условие выполняется - фигура падает свободно(если мы никак не вмешиваемся в управление фигурой)
            if not check_position(rectangle, falling_fig, adjY=1):  #смотрим приземлились ли мы
                filling_field(rectangle, falling_fig)  #если да, то добавляем фигуру на поле, тк поле "заполняется" фигурой
                points += clear_field(rectangle)  #добавляем очки которые даются когда очищается ряд в поле
                level, fall_figure_speed = figure_speed(points)  #счетчик очков от которого меняется скорость движения фигуры
                falling_fig = None #если фигура приземлилась то она уже не падает, ставим на нан
            else:  #фигура не приземлилась, идем вниз
                falling_fig["y"] += 1  #смещаемся по координате у вниз
                last_fall = time.time() #считаем время

        app.fill(color_bg) #заливаем задний фон
        draw_main_title()  #рисуем заголовок игры
        game_field(rectangle)  #рисуем игровое поле
        draw_info_labels(points, level) # рисуем информационные надписи про кол-во очков и какой уровень
        if falling_fig != None: #если фигура падает, а значит вообще она существует то
            draw_figure(falling_fig) #рисуем ее с помощью функции
        pg.display.update() #обновляем экран
        clock.tick(fps)  #используем указанное кол-во фпс чтобы питон не грузил процессор и у всех все было равномерно




def empty_game_field():  #создаем пустое игровое поле
    rectangle = []  #список(как матрица-двумерный), который будет заполнен "="(пустыми ячейками) те наше поле заполнено "=" изначально по всей площади поля
#занятые ячейки в дальнейшем принимают значения 0, 1, 2, 3, 4, 5 – в соответствии с индексами цветов фигур в brightcolors
    for i in range(rect_width):  #пройтись по ширине всего поля
        rectangle.append([not_filled] * rect_height)  #заполнять поле незаполненными блоками исходя из высоты поля
    return rectangle  #передает значение из функции в программу


def filling_field(rectangle, figure):  #для заполнения поля
    for x in range(figure_width):  #перебираем ширину и высоту поля
        for y in range(figure_height):
            #пока фигура двигается, ее блоки не принадлежат к содержимому поля, добавление происходит после приземления(для этого учитываем все остальные функции)
            if figures[figure["shape"]][figure["rotation"]][y][x] != not_filled:  #если в нашем словаре из фигур сама фигура и ее повороты учитывая координаты в поле не равно пусто, то есть, заполнены
                rectangle[x + figure["x"]][y + figure["y"]] = figure["color"]  #если фигура занимает место в игровом поле, тогда заполняем поле этой фигурой учитывая координаты и даем ей цвет;


def in_field(x, y): #по координатам смотрим есть ли фигура в поле; чтобы фигура не вылазила за границы поля
    return x >= 0 and x < rect_width and y < rect_height


def game_field(rectangle):  #само игровое поле в виде прямоугольника
    #граница игрового поля(где рисуем, какой цвет, размеры, шестерка чтобы у нас не создалось полностью закрашенное поле цветом, а лишь его границы указанного цвета)
    pg.draw.rect(app, color_rectangle, (side_distance - 5, top_distance - 5, (rect_width * cube) + 11, (rect_height * cube) + 11),
                 6)
    #фон игрового поля(где, цвет, размеры учитывая наше поле и границы окна, а так же блоков, тут уже заливаем полностью цветом, поэтому после размеров ничего не пишем)
    pg.draw.rect(app, color_bg, (side_distance, top_distance, cube * rect_width, cube * rect_height))
    for x in range(rect_width): #перебираем ширину высоту и рисуем игровое поле с помощью функции которая рисует блоки
        for y in range(rect_height):
            draw_cube(x, y, rectangle[x][y])


def full_filled_rows(rectangle, y):  #смотрим заполнены ли ряды полностью
    for x in range(rect_width):  #перебираем ширину поля
        if rectangle[x][y] == not_filled:  #если координаты поля равны пустому месту(ячейкам "="), передаем фолс значение, ибо не очищаем ряд
            return False  #возвращаем в программу фолс
    return True  #если координаты не равны пустому месту, то есть хотя все координаты в ряду заполнены блоками, значит очищаем его(возвращаем тру)


def clear_field(rectangle):  #очистка поля
    removed_rows = 0  #счетчик кол-ва удаленных рядов
    y = rect_height - 1  #координата ряда поля; после удаления одного ряда продолжает указывать на его номер; нужно для того, чтобы перейти к удалению других заполненных рядов, если они смещаются на место только что удаленного; в случае если других заполненных рядов пока нет, происходит уменьшение у
    while y >= 0:  #если координата ряда поля больше либо равна 0
        if full_filled_rows(rectangle, y):  #функция по проверке заполненных рядов
            for pushDownY in range(y, 0, -1):  #у - начало ренджа; -1 - инкремент для у; 0- конец ренджа
                for x in range(rect_width):  #учитываем ширину поля
                    rectangle[x][pushDownY] = rectangle[x][pushDownY-1]  #переместим вниз на 1 ряд все ряды, которые находятся над тем что удаляется(возвращаем тру функции, идет очистка поля)
            for x in range(rect_width):  #учитываем ширину поля
                rectangle[x][0] = not_filled  #когда ряд очистился заполняем по координате х (целый нулевой ряд) пустыми значениями("=")(что поле теперь не заполнено) все блоки в ряду
            removed_rows += 2 #если функция вернула тру(очистила ряд в поле), прибавляем 1 ряд к счетчику удаленных рядов
        else:  #иначе(если функция вернула фолс)
            y -= 2  #ничего не происходит (если заполненных рядов пока нет)
    return removed_rows  #возвращаем в программу значение сколько рядов удалено


def check_position(rectangle, figure, adjX = 0, adjY = 0):  #проверять позицию блоков в поле чтобы не вылазили за границы и не находили на другие уже существующие блоки
    for x in range(figure_width):  #перебираем ширину и высоту поля
        for y in range(figure_height):
            above_field = y + figure["y"] + adjY < 0  #если фигура над полем (суммируем координаты фигуры с координатами поля)
            if above_field or figures[figure["shape"]][figure["rotation"]][y][x] == not_filled: #если условия ниже не выполняются, то есть ячейки свободны и ничем не заполнены, значит игра продолжается(если любая наша фигура и ее повороты учитывая её координаты попадают на пустые ячейки поля)
                continue #продолжаем
            if not in_field(x + figure["x"] + adjX, y + figure["y"] + adjY):  #суммируем сообственные координаты фигуры с координатами поля
                return False  #фолс потому что фигура может вылезти за границы, проверка используя функцию "в поле"
            if rectangle[x + figure["x"] + adjX][y + figure["y"] + adjY] != not_filled: #проверяем если в самом поле фигуры накладываются одна на одну(т.е. суммируя координаты мы получаем что ячейки совпадают, а значит заполненные уже чем-то)
                return False  #фолс потому что фигура наложилась на какую-либо другую
    return True #возвращаем значение в программу
    #так же вернет False, если прямоугольник уже заполнен настолько, что движение вниз невозможно


def get_figure():  #чтобы получать случайную фигуру по цвету и случайный угол поворота фигуры
    shape = random.choice(list(figures.keys()))  #random.choice возвращает случайный элемент из списка
    #keys() возвращает объект представления;(o.п.) содержит ключи словаря в виде списка;о.п. отражает все изменения, внесённые в словарь
    new_figure = {"shape": shape,
                  "rotation" : random.randint(0, len(figures[shape]) -1),  #случайный поворот фигуры, randint - возвращает целое число, выбранный элемент из указанного диапазона.
                  "x": int(rect_width / 2) - int(rect_width / 5),  #получаем координаты х учитывая ширину поля
                  "y": -2,  #фигура генерируется выше чем высота нашего поля
                  "color": random.randint(0, len(brightcolors) - 1)}  #получаем случайный цвет фигуры, исходя из всех ярких цветов которые записаны в список
    return new_figure  #возвращаем полученную фигуру в программу, каждая новая падающая фигура генерируется в позиции, которая расположена чуть выше стакана.


def convert_coordinaty(cube_x, cube_y):  #преобразование координат; используется для функции draw_cube, которая рисует кубики, которые состоят из 5 элементов
    return (side_distance + (cube_x * cube)), (top_distance + (cube_y * cube))  #возвращаем значение в программу; учитываем расстояние между полем и окном сбоку и сверху


def draw_cube(cube_x, cube_y, color, pixel_x = None, pixel_y = None):  #прорисовка кубиков, из которых состоят фигуры
    if color == not_filled:  #если цветом ничего не заполнено(кубиков нет - цвета тоже нет)
        return  #возвращаем это в программму
    if pixel_x == None and pixel_y == None:  #если координаты не преобразованы берем их из предыдущего метода
        pixel_x, pixel_y = convert_coordinaty(cube_x, cube_y)
    pg.draw.rect(app, brightcolors[color], (pixel_x + 2, pixel_y + 2, cube - 2, cube - 2), 0, 4)  #рисуем блоки(фигуры можно вписать в прямугольник) на поле с яркими цветами по координатам
    pg.draw.rect(app, darkcolors[color], (pixel_x + 2, pixel_y + 2, cube - 5, cube - 5), 0, 4)  #отнимаем от размера блока 5 тк 5 кубиков в каждой фигуре
    pg.draw.circle(app, brightcolors[color], (pixel_x + cube / 2, pixel_y + cube / 2), 5)  #рисуем мини кружочки на наших блоках как "тени"


def draw_figure(figure, pixel_x = None, pixel_y = None): #прорисовываем фигуры с помощью функции draw_cube() в которой мы прорисовывали сами кубики
    figure_for_drawing = figures[figure["shape"]][figure["rotation"]]  #фигура которую нам нужно будет прорисовать выбирается с случайным видом и случайным поворотом из словаря наших фигур
    if pixel_x == None and pixel_y == None:  #если пиксели свободны, то есть поле пустое
        pixel_x, pixel_y = convert_coordinaty(figure["x"], figure["y"])  #превращаем их в х,у координаты с помощью функции каписанной ранее, которая их преобразовывает

    for x in range(figure_width):  #чтобы прорисовать фигуру надо узнать ее размеры по ширине и высоте
        for y in range(figure_height):
            if figure_for_drawing[y][x] != not_filled:  #если фигура которая выбралась случайным образом занимает определенное место по координатам
                draw_cube(None, None, figure["color"], pixel_x + (x * cube), pixel_y + (y * cube))  #с помощью предыдущей функции draw_cube прорисовываем тогда кубики по форме фигуры со случайным цветом по пикселям где учитывается размер куба(по х,у) заданный изначально

def draw_main_title():  #прорисовка названия игры
    title_app = main_font.render("Tetris", True, main_label) #название с рендером шрифта и цветом для него
#main_font - определенный системный шрифт мой заданный ранее; render tak kak pygame не предоставляет прямого способа записи текста на поверхность.
#метод render() должен быть использован для создания объекта surface (app) из текста, который затем может быть выведен на экран
    title_rect = title_app.get_rect()  #метод get_rect() - создает новый прямоугольник с координатами (0,0);
    title_rect.center = (app_width - 300, 30)  #не хочу координаты (0,0); передаем аргумент get_rect, используем topleft(можно и center) и задаем координаты x,y
    app.blit(title_app, title_rect)  #по сути рисуем одно изображение(надпись) на другом те на нашей поверхности, экране; способ копирования содержимого одной поверхности на другую


def draw_info_labels(points, level): #прорисовувываем остальные надписи, которые говорят о текущем уровне и количестве очков
    points_app = other_fonts.render(f'points: {points}', True, color_labels) #используем переменную из основного игрового цикла которая считает кол-во очков и задаем цвет
    points_rect = points_app.get_rect()  #процесс идентичен функции draw_main_title()
    points_rect.topleft = (app_width - 580, 180)
    app.blit(points_app, points_rect)

    level_app = other_fonts.render(f'level: {level}', True, color_labels)  #используем переменную из основного игрового цикла которая считает на каком уровне мы находимся
    level_rect = level_app.get_rect()  #процесс идентичен функции draw_main_title()
    level_rect.topleft = (app_width - 580, 250)
    app.blit(level_app, level_rect)

    escape_app = other_fonts.render(f'exit:', True, color_labels) #задаем переменную которая просто будет иметь надпись которая расскажет как выйти из игры
    escape_app2 = other_fonts.render(f'escape/cross', True, color_labels)
    escape_rect = escape_app.get_rect()  #процесс идентичен функции draw_main_title()
    escape_rect2 = escape_app2.get_rect()
    escape_rect.topleft = (app_width - 590, 440)
    escape_rect2.topleft = (app_width - 590, 460)
    app.blit(escape_app, escape_rect)
    app.blit(escape_app2, escape_rect2)


def textt(text, font, color):  #принимает текст, шрифт и цвет с помощью метода рендер(рисует текст на поверхности)
    app_surface = font.render(text, True, color)
    return app_surface, app_surface.get_rect()  #возвращает готовые объекты(поверхность(экран) и сам прямоугольник))


def show_text(text):  #чтобы текст был на экране
    title_app, title_rect = textt(text, other_fonts, main_label)  #объекты из метода техт которые рендерились обрабатываются блитом, выводит надписи и название игры.
    title_rect.center = (int(app_width / 2) - 3, int(app_height / 2) - 3)  #расположение надписи игры по центру учитывая размеры окна
    app.blit(title_app, title_rect)  #накладывать одно изображение на другое (blitting is drawing)

    while keys() == None:  #метод проверки всех кнопок; если ничего не нажимаем то
        pg.display.update()  #обновляем экран
        clock.tick()  #обновить часы, вычисляет сколько миллисекунд прошло с момента предыдущего вызова, вызывается один раз за кадр


def figure_speed(points):  #скорость падения фигуры зависит от уровня
    level = int(points / 2) + 1  #увеличивать уровень на один при делении полученного кол-ва очков на кол-во очков выделенное на один уровень(4)
    fall_figure_speed = 0.27 - (level * 0.025)  #скорость падения фигуры увеличивается
    return level, fall_figure_speed  #передает значение из функции в программу


def keys():  #проверка всех кнопок
    Quit()  #функция которая отвечает за выход из игры по крестику
    for e in pg.event.get([KEYDOWN, KEYUP]):  #список прошедших событий и если клавиша нажата - продолжаем игру
        if e.type == KEYDOWN:
            continue
        return e.key #событие описывает одно взаимодействие между пользователем и клавишей на клавиатуре; передает это в программу из функции
    return None  #ничего не возвращает


def Quit():  #выход из игры при нажатии на крестик
    for e in pg.event.get(QUIT):  #event.get() - возвращает список прошедших событий
         #проверяет нажали ли мы на крестик
        stopGame() #если нажали - выходим из игры
    for e in pg.event.get(KEYUP):
        if e.key == K_ESCAPE:
            stopGame()
        pg.event.post(e)


def stopGame(): #выход из игры
    pg.quit()
    sys.exit()


if __name__ == "__main__":
    osnova()
#позволяет выполнять код, когда файл запускается как скрипт, но не когда он импортируется как модуль;
#способ хранения кода, который должен выполняться только тогда, когда файл выполняется как сценарий.
#стандартный код, который защищает пользователей от случайного вызова сценария, когда они не собирались этого делать.
#интерпретатор будет искать импортированый файл и перед выполнением этого модуля он присвоит имя из оператора import пер искать импортированый файл и перед выполнением этого модуля он присвоит имя из оператора import переменной __name__